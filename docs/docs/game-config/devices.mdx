---
sidebar_position: 5
---
import DeviceSchema from "@site/static/schemas/device/deviceSchema.json";
import JSONSchemaViewer from "@theme/JSONSchemaViewer";
import InlineSchemaDisplay from '@site/src/components/InlineSchemaDisplay';
import generateResolverOptions from "@site/src/components/shared-lib/generateResolverOptions.tsx";


# Devices

Within the simulation environment, devices represent interactive elements that mimic any smart objects commonly found in domestic or workplace contexts, such as lights, thermostats, smart meters, coffee machines, smart speakers, smart TVs, blinds, and more.
Each device is a structured object placed spatially within the 3D simulated environment and is associated with a set of interaction modalities and visual states. 
Participants can engage with these devices, and their state can be monitored or changed by the rule engine.

Devices are embedded within simulation space by assigning them to specific walls in the environment (see Wall Configuration Schema). While each wall can host multiple devices, each device 
instance is placed on only one wall. This constraint allows for a coherent mapping of the virtual environment and ensures consistent spatial interactions.

:::tip Device Configuration
Always start by defining the basic properties (name, id, position, interactions) before adding complex visual states. This makes it easier to test and debug your device configuration.
:::

## JSON Schema

<JSONSchemaViewer schema={ DeviceSchema } resolverOptions={generateResolverOptions({"basePath": "/schemas/device"})} />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={DeviceSchema} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas/device"})} 
    title="Device Schema"
    />
</details>


## Device Identification

Each device requires two identifiers: a human-readable `name` and a unique system `id`.

- `name`: The display name shown to users (e.g., "Deep Fryer", "Coffee Machine"). This field enhances usability and participant immersion by providing intuitive, 
natural-language names for each device.

- `id`: A unique system-wide identifier used for all internal referencing. The `id` is essential for:
    - Rules: Referencing devices in preconditions and actions (See [Rule](rules.mdx)).
    - Tasks: Specifying devices in goals and default properties (See [Task](tasks.mdx)).
    - Game Logic: Managing internal device state and inter-device interactions (See [Interactions ](interaction_types.mdx))

```json
{
    "name": "Deep Fryer",
    "id": "deep_fryer",
    // ... other properties
}
```


### Position

The `position` property determines where a device appears on a wall and how it is displayed. It contains the following attributes that define its transform.

- `x`: The horizontal coordinate (in pixels) on the wall.
- `y`: The vertical coordinate (in pixels) on the wall.
- `scale`: A multiplier for the device's size (e.g., 1 for original size, 0.5 for half size).
- `origin`: Reference point for positioning (1 represents center)

:::tip Origin Property
The origin dictates which part of the device's image is placed at the (x, y) coordinates:

- origin: 0: Aligns the top-left corner of the image to the (x, y) point.
- origin: 1: Aligns the center of the image to the (x, y) point.
:::

These positioning parameters are fully compatible with Phaser 3’s GameObject model, which underpins the simulation’s rendering layer. For more information:
- [Scale Documentation](https://docs.phaser.io/api-documentation/namespace/gameobjects-components-transform)
- [Origin Documentation](https://docs.phaser.io/api-documentation/namespace/gameobjects-components-origin)

### Interactions

The interactions property defines how participants can interact with the device. Common interaction types include:

1. Boolean Actions (e.g., power switches)
2. Numerical Actions (e.g., temperature controls)

:::danger Interaction Validation
Always validate that your interaction types match the expected input ranges in your visual states. Mismatched values can lead to undefined behavior.
:::

Each interaction type has specific properties that control its behavior and visibility conditions. Detailed interaction configuration is covered in the dedicated [Interactions page](interaction_types.mdx).

### Visual States

Visual states control how the device appears based on its current state and interaction values. This allows devices to visually reflect their status and settings.

:::tip Visual States Best Practice
Always include a default state as a fallback for when no conditions are met. This prevents devices from becoming invisible due to undefined states.
:::

#### Structure

Visual states are defined as an array of state objects. Each state object can have:

1. `default`: Boolean indicating if this is the fallback state
2. `conditions`: Array of conditions that must be met for this state
3. `image`: Path to the image asset for this state
4. `position`: Optional position override for this specific visual state

#### Position Overrides in Visual States

Visual states can optionally override the device's default position properties for specific states. This is useful when different states require different positioning or scaling.

```json
{
    "default": false,
    "conditions": [
        { "name": "Open", "value": true }
    ],
    "image": "assets/images/alice_room/devices/wall1_bookopen.webp",
    "position": {
        "scale": 0.2
    }
}
```

The position override can include any combination of:
- `x`: X-coordinate override
- `y`: Y-coordinate override
- `scale`: Scale factor override
- `origin`: Origin point override

:::info Position Override Usage
Position overrides are particularly useful for:
- Changing scale when devices transform (e.g., book opening)
- Adjusting position for different visual representations
- Fine-tuning alignment for specific states
:::

#### Examples

##### Basic Default State

```json
{
    "default": true,
    "image": "assets/images/living_room/devices/tv.png"
}
```

##### Simple Power States

```json
[
    {
        "conditions": [
            { "name": "Power", "value": true }
        ],
        "image": "assets/images/living_room/devices/tv_on.png"
    },
    {
        "conditions": [
            { "name": "Power", "value": false }
        ],
        "image": "assets/images/living_room/devices/tv_off.png"
    }
]
```

##### State with Position Override

```json
[
    {
        "default": true,
        "image": "assets/images/alice_room/devices/wall1_book.webp"
    },
    {
        "default": false,
        "conditions": [
            { "name": "Open", "value": true }
        ],
        "image": "assets/images/alice_room/devices/wall1_bookopen.webp",
        "position": {
            "scale": 0.2
        }
    }
]
```

##### Complex Multi-Condition States

This example shows an oven with power and temperature states:

```json
[
    {
        "default": true,
        "image": "assets/images/kitchen/devices/oven_off.png"
    },
    {
        "conditions": [
            { "name": "Power", "value": true },
            { "name": "Temperature", "operator": "<", "value": 50 }
        ],
        "image": "assets/images/kitchen/devices/oven_on_low.png"
    },
    {
        "conditions": [
            { "name": "Power", "value": true },
            { "name": "Temperature", "operator": ">=", "value": 50 },
            { "name": "Temperature", "operator": "<", "value": 100 }
        ],
        "image": "assets/images/kitchen/devices/oven_on_med.png"
    },
    {
        "conditions": [
            { "name": "Power", "value": true },
            { "name": "Temperature", "operator": ">=", "value": 100 }
        ],
        "image": "assets/images/kitchen/devices/oven_on_high.png"
    }
]
```

:::danger Visual State Overlap
It must be always taken care that the conditions of visual states do not overlap. An overlap of two applying visual states will lead to the situation that the first visual state in the array that applies will be visible.
:::

### Important Considerations

1. **Condition Evaluation**: All conditions within a state are combined using AND logic. Every condition must be true for the state to activate.

2. **State Priority**: Visual states are evaluated in order. The first state whose conditions are met will be displayed.

:::tip State Organization
Order your states from most specific to most general conditions to ensure proper evaluation. More specific conditions should appear first in the array.
:::

3. **Condition Operators**: Available operators include:
   - Equality: `==`, `!=`
   - Comparison: `>`, `>=`, `<`, `<=`
   - Direct value matching for booleans

4. **Asset Management**: Ensure all referenced image paths are valid and assets are properly loaded in your game configuration.

:::danger Asset Loading
Missing or invalid image assets will cause runtime errors. Always verify that all referenced image paths exist in your project structure.
:::

## Complete Device Example

Here's a complete example showing all device properties:

```json
{
    "name": "Deep Fryer",
    "id": "deep_fryer",
    "image": "assets/images/shared_room/devices/deep_fryer_off.jpg",
    "position": {
        "x": 657,
        "y": 285,
        "scale": 1,
        "origin": 1
    },
    "interactions": [
        {
            "InteractionType": "Boolean_Action",
            "name": "Power",
            "inputData": {
                "valueType": ["PrimitiveType", "Boolean"],
                "unitOfMeasure": null,
                "type": {
                    "True": "On",
                    "False": "off"
                }
            },
            "currentState": {
                "visible": null,
                "value": false
            }
        }
    ],
    "visualState": [
        {
            "default": true,
            "image": "assets/images/shared_room/devices/wall1_deepfryer.webp"
        },
        {
            "default": false,
            "conditions": [
                { "name": "Power", "value": true }
            ],
            "image": "assets/images/shared_room/devices/wall1_deepfryer_on.webp"
        }
    ]
}
```

## Best Practices

1. **Device Identification**
   - Use descriptive names for user display
   - Use consistent, lowercase IDs with underscores
   - Ensure IDs are unique across all devices

2. **Visual State Management**
   - Always include a default state as fallback
   - Order states from most specific to most general
   - Use position overrides sparingly and purposefully

3. **Asset Organization**
   - Keep image assets optimized for performance
   - Use consistent naming conventions for asset files
   - Organize assets in logical folder structures

4. **Configuration Testing**
   - Test all possible state combinations
   - Verify all interaction types work correctly
   - Ensure position overrides don't cause visual issues

:::tip Documentation
Maintain a list of all custom devices and their expected behaviors in your project documentation. Include device IDs, interaction types, and any special visual state behaviors.
:::

