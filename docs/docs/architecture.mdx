# V-SHINE Platform Architecture

The V-SHINE Study Platform is a distributed web application designed for conducting smart home simulation research. The architecture employs real-time communication, modular services, and flexible data storage to support interactive research studies.

## System Overview

The platform consists of four main components working together

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          V-SHINE Study Platform                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚      V-SHINE FRONTEND   â”‚â—„â”€â”€â”€Socket.IOâ”€â”€â”€â–ºâ”‚      V-SHINE BACKEND        â”‚    â”‚
â”‚  â”‚                         â”‚                 â”‚                             â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚  â”‚  â”‚ React Componentsâ”‚    â”‚   WebSocket     â”‚  â”‚   Socket Handlers   â”‚    â”‚    â”‚
â”‚  â”‚  â”‚ â€¢ Study Page    â”‚    â”‚   Events:       â”‚  â”‚ â€¢ Device Interactionâ”‚    â”‚    â”‚
â”‚  â”‚  â”‚ â€¢ Task Managementâ”‚   â”‚   â€¢ device-int  â”‚  â”‚ â€¢ Task Management   â”‚    â”‚    â”‚
â”‚  â”‚  â”‚ â€¢ Explanations  â”‚    â”‚   â€¢ game-start  â”‚  â”‚ â€¢ Explanation Req   â”‚    â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â€¢ task-abort  â”‚  â”‚ â€¢ Game Events       â”‚    â”‚    â”‚
â”‚  â”‚           â”‚             â”‚                 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                 â”‚           â”‚                 â”‚    â”‚
â”‚  â”‚  â”‚ Phaser 3 Game   â”‚    â”‚                 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚  â”‚  â”‚ â€¢ GameScene     â”‚    â”‚                 â”‚  â”‚    Next.js APIs     â”‚    â”‚    â”‚
â”‚  â”‚  â”‚ â€¢ Device Objectsâ”‚â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¤ â€¢ /api/create-session    â”‚    â”‚
â”‚  â”‚  â”‚ â€¢ Room Layout   â”‚    â”‚   HTTP Requests â”‚  â”‚ â€¢ /api/game-data    â”‚    â”‚    â”‚
â”‚  â”‚  â”‚ â€¢ Smarty        â”‚    â”‚                 â”‚  â”‚ â€¢ /api/verify-session    â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                 â”‚  â”‚ â€¢ /api/complete-study    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚                                              â”‚           â”‚                 â”‚    â”‚
â”‚                                              â”‚           â–¼                 â”‚    â”‚
â”‚                                              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚                                              â”‚  â”‚   MongoDB Driver    â”‚    â”‚    â”‚
â”‚                                              â”‚  â”‚ â€¢ Connection Pool   â”‚    â”‚    â”‚
â”‚                                              â”‚  â”‚ â€¢ Session Mgmt      â”‚    â”‚    â”‚
â”‚                                              â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                            â”‚                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                     MONGODB DATABASE                    â”‚               â”‚    â”‚
â”‚  â”‚                                                         â–¼               â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚
â”‚  â”‚  â”‚sessions  â”‚  â”‚  tasks   â”‚  â”‚ devices  â”‚  â”‚expl.     â”‚  â”‚  logs    â”‚   â”‚    â”‚
â”‚  â”‚  â”‚â€¢ metadataâ”‚  â”‚â€¢ status  â”‚  â”‚â€¢ states  â”‚  â”‚â€¢ content â”‚  â”‚â€¢ events  â”‚   â”‚    â”‚
â”‚  â”‚  â”‚â€¢ socketIdâ”‚  â”‚â€¢ timing  â”‚  â”‚â€¢ values  â”‚  â”‚â€¢ ratings â”‚  â”‚â€¢ timing  â”‚   â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚              EXTERNAL EXPLANATION ENGINE (Optional)                     â”‚    â”‚
â”‚  â”‚                                                                         â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚    â”‚ 
â”‚  â”‚  â”‚     REST Interface      â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   WebSocket Interface   â”‚      â”‚    â”‚
â”‚  â”‚  â”‚                         â”‚           â”‚                         â”‚      â”‚    â”‚
â”‚  â”‚  â”‚ POST /logger            â”‚           â”‚ Socket.IO Client        â”‚      â”‚    â”‚
â”‚  â”‚  â”‚ POST /explanation       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â€¢ user_log (emit)       â”‚      â”‚    â”‚
â”‚  â”‚  â”‚                         â”‚           â”‚ â€¢ explanation_receival  â”‚      â”‚    â”‚
â”‚  â”‚  â”‚ HTTP Request/Response   â”‚           â”‚   (listen)              â”‚      â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚                         â”‚      â”‚    â”‚
â”‚  â”‚               â–²                        â”‚ Real-time bidirectional â”‚      â”‚    â”‚
â”‚  â”‚               â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚    â”‚
â”‚  â”‚               â”‚                                     â–²                   â”‚    â”‚
â”‚  â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚    â”‚
â”‚  â”‚                          Backend selects interface                      â”‚    â”‚
â”‚  â”‚                        based on explanation_config.json                 â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Core Components

### ğŸ® V-SHINE Frontend

**Technology Stack**: React 19 + Next.js 15 + Phaser 3 + Socket.IO Client + TypeScript

The frontend combines traditional web UI components with a game engine for interactive smart home simulation.

#### React Layer (`/src/app/study/`)
- **Study Page**: Main orchestrator managing WebSocket connections and React state
- **Environment Bar**: Task display and progress tracking
- **Smart Home Sidebar**: Device status and control interface  
- **Task Abort Modal**: Task management with user feedback
- **Socket Service**: Centralized WebSocket communication manager

#### Phaser 3 Game Engine (`/src/app/study/game/`)
- **GameScene.ts**: Main coordinator setting up rooms, devices, and Smarty assistant
- **Device.ts**: Interactive device objects with visual states and click handlers
- **Room.ts**: Spatial boundaries and device containers
- **Smarty.ts**: Virtual assistant avatar for guidance
- **EventsCenter.ts**: Bridge between React and Phaser using event emitters

#### Frontend-Backend Communication
```javascript
// Socket.IO Events - Frontend Emits
{
  'device-interaction': { sessionId, device, interaction, value },
  'game-start': { sessionId },
  'task-abort': { sessionId, taskId, reason },
  'explanation_request': { sessionId, deviceId },
  'explanation_rating': { sessionId, explanationId, rating }
}

// Socket.IO Events - Frontend Listens
{
  'update-interaction': { device, interaction, value, source },
  'explanation': { content, rating_options, explanationId },
  'game-update': { task_completed, next_task, device_updates }
}
```

### ğŸ”§ V-SHINE Backend

**Technology Stack**: Next.js 15 + Socket.IO Server + MongoDB Driver + Node.js

The backend provides both HTTP APIs for session management and real-time Socket.IO handlers for game interactions.

#### Next.js API Routes (`/src/app/api/`)
- **`/api/create-session`**: Initializes new study session with tasks and device states
- **`/api/game-data`**: Returns game configuration merged with current device states
- **`/api/verify-session`**: Validates active sessions and handles timeouts
- **`/api/complete-study`**: Finalizes study data collection and cleanup

#### Socket.IO Event Handlers (`/src/lib/server/socket/`)
- **`deviceInteractionHandler.js`**: Core interaction processing with rule evaluation
- **`gameStartHandler.js`**: Session initialization and environment setup
- **`taskAbortHandler.js`**: Task abortion with reasoning collection
- **`taskTimeoutHandler.js`**: Automatic task timeout handling
- **`explanationRequestHandler.js`**: On-demand explanation delivery
- **`explanationRatingHandler.js`**: User feedback collection for explanations

#### Service Layer (`/src/lib/server/services/`)
- **`commonServices.js`**: Session validation, task management, rule checking
- **`rulesService.js`**: Automated device behavior and cascading updates
- **`deviceUtils.js`**: Device state management and interaction logging

### ğŸ—„ï¸ MongoDB Database

**Collections and Data Relationships**:

```
sessions Collection
â”œâ”€â”€ sessionId (unique identifier)
â”œâ”€â”€ startTime, lastActivity (timing data)
â”œâ”€â”€ isCompleted, completionTime (status tracking)  
â”œâ”€â”€ customData (participant metadata)
â”œâ”€â”€ socketId (real-time connection tracking)
â””â”€â”€ explanationCache (performance optimization)

tasks Collection  
â”œâ”€â”€ userSessionId (foreign key to sessions)
â”œâ”€â”€ taskId, task_order (task identification)
â”œâ”€â”€ isCompleted, isAborted, isTimedOut (status flags)
â”œâ”€â”€ startTime, endTime (timing measurements)
â”œâ”€â”€ taskDescription (study instructions)
â””â”€â”€ abortionReason (user feedback)

devices Collection
â”œâ”€â”€ userSessionId (foreign key to sessions)  
â”œâ”€â”€ deviceId (unique device identifier)
â””â”€â”€ deviceInteraction[] (array of interaction states)
    â”œâ”€â”€ name (interaction property name)
    â”œâ”€â”€ type (boolean, numerical, stateless)
    â”œâ”€â”€ value (current state value)
    â””â”€â”€ timestamp (last modification time)

explanations Collection  
â”œâ”€â”€ userSessionId (foreign key to sessions)
â”œâ”€â”€ explanationId (unique identifier)
â”œâ”€â”€ content (explanation text)
â”œâ”€â”€ rating (user feedback: like/dislike/none)
â”œâ”€â”€ triggerContext (interaction that caused explanation)
â”œâ”€â”€ timestamp (generation time)
â””â”€â”€ metadata (explanation engine details)

logs Collection
â”œâ”€â”€ userSessionId (foreign key to sessions)
â”œâ”€â”€ eventType (device_interaction, task_event, etc.)
â”œâ”€â”€ eventData (structured event information)
â”œâ”€â”€ timestamp (precise event timing)
â””â”€â”€ metadata (additional context data)
```

### ğŸ¤– External Explanation Engine (Optional)

The platform supports integration with external explanation services to provide AI-generated explanations for user interactions. This is an optional component that can be implemented using various technologies and approaches.

#### Integration Approach

The V-SHINE platform provides a **flexible integration layer** that supports different explanation service implementations through standardized interfaces:

**Dual Communication Support**:
- **WebSocket Interface**: Real-time bidirectional communication for automatic explanations
- **REST Interface**: HTTP-based request/response for on-demand explanations
- **Configurable Selection**: Backend chooses communication mode based on study configuration

**Service Requirements**:
- **Input**: Receives user interaction data (device, action, context)
- **Processing**: Generates explanations using AI/ML models, rule-based systems, or other approaches
- **Output**: Returns structured explanation content with optional rating mechanisms

#### Implementation Flexibility

Explanation services can be implemented using any technology stack:
- **AI/ML Services**: Integration with LLMs, expert systems, or custom models
- **Rule-Based Systems**: Template-driven explanations based on interaction patterns
- **Hybrid Approaches**: Combining multiple explanation generation strategies
- **Cloud Services**: Integration with external AI APIs or services

#### Backend Integration
```javascript
// Factory pattern provides unified interface for any explanation service
const explanationEngine = createExplanationEngine(explanationConfig);

// Standard callback interface regardless of implementation
explanationEngine.sendUserLog(interactionData, (explanation) => {
  // Process explanation response
  socket.emit('explanation', explanation);
});
```

:::info Example Implementation
The repository includes a sample Python Flask explanation engine as a reference implementation, demonstrating both REST and WebSocket communication patterns. This serves as a starting point for developing custom explanation services.
:::

## Data Flow Patterns

### ğŸ”„ Device Interaction Flow

```
User Click (Phaser) â†’ EventsCenter â†’ React State â†’ Socket.IO Client
                                                               â”‚
                                                               â–¼
Backend Socket Handler â† MongoDB Update â† Rule Evaluation â† Session Validation
        â”‚
        â–¼
Real-time Broadcast â†’ Frontend State Sync â†’ Phaser Visual Update
```

**Detailed Steps**:
1. **User Interaction**: User clicks device in Phaser game
2. **Event Bridge**: EventsCenter forwards to React components
3. **Socket Emission**: React emits `device-interaction` event
4. **Backend Processing**: Socket handler validates session and processes interaction
5. **Rule Evaluation**: Rules engine checks for automated device responses
6. **Database Update**: Device states and interaction logs saved to MongoDB
7. **Real-time Sync**: Updated states broadcast to all connected clients
8. **Frontend Update**: React state and Phaser visuals reflect new device states

### ğŸ“ Explanation Generation Flow

```
Trigger Event â†’ Backend Handler â†’ Explanation Engine Selection
                                          â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â–¼                                   â–¼
                  REST Request                        WebSocket Event
               (On-demand mode)                       (Automatic mode)
                        â”‚                                   â”‚
                        â–¼                                   â–¼
              HTTP Response â†â”€â”€â”€â”€   Service   â”€â”€â”€â”€â†’    Socket Event
                        â”‚                                   â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â–¼
                          Explanation Callback â†’ Database Storage
                                      â”‚
                                      â–¼
                            Frontend Toast Display
```

### ğŸ“Š Task Management Flow

```
Task Start Event â†’ Task Begin Logging â†’ Frontend Task Display
                                              â”‚
                                              â–¼
User Interactions â†’ Goal Checking â†’ Task Completion Detection
                                              â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â–¼                                                        â–¼
            Task Completed                                            Task Aborted/Timeout
                  â”‚                                                        â”‚
                  â–¼                                                        â–¼
        Next Task Setup â†’ Device State Reset â†’ Frontend Update      Abort Reason Logging
```

**Detailed Steps**:
1. **Task Initialization**: Game start triggers first task activation
2. **User Progress**: Device interactions checked against task goals  
3. **Completion Detection**: Backend validates when task objectives are met
4. **State Transition**: Current task marked complete, next task activated
5. **Device Reset**: Device states updated for new task requirements
6. **Frontend Sync**: Task progress and device states updated in real-time

### ğŸš€ Session Lifecycle

```
HTTP: POST /api/create-session â†’ Session + Tasks + Devices Created in MongoDB
                                              â”‚
                                              â–¼
HTTP: GET /api/game-data â†’ Game Config + Current Device States Merged
                                              â”‚
                                              â–¼
Frontend: Socket.IO Connection â†’ Real-time Event Handlers Registered
                                              â”‚
                                              â–¼
Socket: game-start Event â†’ Study Session Begins â†’ Task Timer Starts
                                              â”‚
                                              â–¼
Real-time Interactions â†’ Device Events â†’ Task Progress â†’ Rule Evaluation
                                              â”‚
                                              â–¼
HTTP: POST /api/complete-study â†’ Final Data Collection â†’ Session Cleanup
```

**Detailed Steps**:
1. **Session Creation**: API creates session record with associated tasks and initial device states
2. **Configuration Loading**: Frontend requests merged game config with current device states
3. **Socket Connection**: Real-time communication established for interactive gameplay
4. **Study Start**: User begins study, first task activated with timer
5. **Interactive Phase**: Device interactions, explanations, task progression
6. **Study Completion**: Final API call collects completion data and marks session finished

## Architecture Patterns

### ğŸ¯ Event-Driven Communication
- **Socket.IO**: Real-time bidirectional communication between frontend and backend
- **EventsCenter**: Decoupled communication between React and Phaser components
- **Callback Patterns**: Asynchronous explanation engine integration

### âš™ï¸ Configuration-Driven Design
- **JSON Configuration**: `game.json` and `explanation.json` define study parameters
- **Dynamic State Merging**: Game configuration merged with real-time device states
- **Flexible Rule System**: JSON-defined automated behaviors and device responses

### ğŸ—ï¸ Modular Service Architecture
- **Specialized Handlers**: Dedicated socket handlers for different event types
- **Shared Services**: Common operations abstracted into reusable services
- **Factory Patterns**: Plugin-style explanation engine selection

### ğŸ”„ State Synchronization
- **Single Source of Truth**: MongoDB serves as authoritative state store
- **Real-time Updates**: Socket.IO ensures frontend reflects backend state changes
- **Session Isolation**: Each user session maintains independent device states

## Security and Performance

### ğŸ” Security Measures
- **Session Validation**: All socket events validate active sessions
- **Input Sanitization**: User inputs validated against JSON schemas
- **Connection Management**: Socket IDs tracked for secure communication

### âš¡ Performance Optimizations
- **MongoDB Connection Pooling**: Efficient database connection management  
- **Explanation Caching**: Generated explanations cached to avoid regeneration
- **Real-time Optimization**: Socket.IO rooms for efficient event broadcasting
- **Static Asset Caching**: Next.js optimization for game assets and configurations

:::info Architecture Benefits
This architecture provides:
- **Scalability**: Modular design supports multiple concurrent research sessions
- **Flexibility**: Configuration-driven approach allows easy study customization
- **Reliability**: Event-driven patterns with comprehensive error handling
- **Research Focus**: Comprehensive logging and data collection for analysis
:::
