---
sidebar_position: 2
---

import CodeBlock from '@theme/CodeBlock';
import generateResolverOptions from "@site/src/components/shared-lib/generateResolverOptions.tsx";
import JSONSchemaViewer from "@theme/JSONSchemaViewer";
import RuleSchema from "@site/static/schemas/ruleSchema.json";
import InlineSchemaDisplay from '@site/src/components/InlineSchemaDisplay';

# Rules
## Rule-Based Interaction Logic in Smart Home Simulation:

To enable dynamic, context-sensitive behavior within the simulated smart environment, we implement a rule-based logic engine that governs the behavior of devices 
and the presentation of explanations. Each rule defines a set of **precondition** that, when satisfied, trigger one or more **actions**. This structure models programmable 
automation scenarios common in real-world smart home ecosystems.

This _Rule-Based Interaction Logic_ is a powerful approach for experimental design, enabling the study of user interaction with smart systems. It allows designers to create scenarios with custom task logic, personalization, and even intentionally 
contradictory or impossible rules. This capability is crucial for researching user problem-solving, cognitive load, and frustration in response to systems that are confusing or appear to be malfunctioning. The rule-based nature 
of the engine also provides a foundation for explanation mechanisms and adaptive explanation systems, where the rules that drive the system's behavior also serve as triggers for transparency features that explain that behavior to the user.
## JSON Schema

<JSONSchemaViewer schema={ RuleSchema } resolverOptions={generateResolverOptions({"basePath": "/schemas"})} />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={RuleSchema} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas"})} 
    title="Device Schema"
    />
</details>


### Rule Components Overview

Each rule within the rules array is a self-contained object with several key properties that define its behavior: id, name, precondition, delay, and action.

- **ID** (optistring, optionaonal): A unique identifier for the rule
- **Name** (string, required): A human-readable name describing the rule's purpose (e.g., "Turn Off Coffee Machine Automatically").
-  **Delay** (number, optional): The time in seconds to wait after the preconditions are met before executing the action. 
This allows for the modeling of system latency or the creation of more naturalistic, timed behaviors.
-  **Preconditions** (array, required): An array of condition objects that represent the _"IF"_ part of a rule. Preconditions specify when a rule becomes eligible for execution. 
All listed preconditions must be met (logical AND).  Different types of preconditions are as follows:
   - **Device State Conditions**
   - **Time conditions**
   - **Contextual Conditions (User's Context and Task)**
- **Actions** (array, required): An array of action objects that represent the _"THEN"_ part of a rule. 
These are the events that occur once the preconditions are satisfied and the delay has elapsed. Supported actions include:
   - **Device Interaction**: Changes a device’s internal state (e.g., turning off a coffee machine).
   - **Explanation Actions**: Issues system-generated explanations

### Rule ID, Name and Delay 

Each rule is identified with two fields: a machine-readable id for programmatic tracking and a human-readable name for clarity.
The optional id serves as a unique system identifier, while the required name describes the rule's purpose for easy debugging and management.
```json
{
    "id": "coffee_machine_rule",
    "name": "Turn Off Coffee Machine",
    // ... rest of rule
}
```

Furthermore, a rule can include an optional `delay` property. It is used to configure a latency period, 
specified in seconds, that must elapse before the rule's actions are executed.

```json
{
    "name": "Turn On Lamp When Book Is Open",
    "delay": 3,
    "precondition": [
        // ... preconditions
    ],
    "action": [
        // ... actions
    ]
}
```

### Precondition

The precondition array is the trigger mechanism for any rule. The framework supports a variety of condition types to create rich, context-aware triggers.

:::info

All preconditions must satisfy to trigger the rule's actions.

:::

#### Device State Conditions 

An interesting feature of the simulation’s rule engine is its ability to monitor and respond to real-time device states. 
Rules may include preconditions that inspect the internal properties of devices in the environment. 
This allows for task progression, automation, and feedback to be dynamically contingent on user interaction patterns with specific smart devices.

Each device-based precondition is structured as follows:
- `type`: Must be set to "Device" to indicate a state-based condition.
- `device`: A unique identifier (ID) corresponding to the target device within the environment (e.g., "coffee_machine").
- `condition`: A logical expression applied to a named device property. The `condition` object contains three elements:
	- `name`: The property to be monitored (e.g., "Number of Coffees Made").
	- `operator`: The logical operator used for evaluation (e.g., `>=` , `==`, `<`).
	- `value`: The threshold or value to compare against.

```json
{
    "type": "Device",
    "device": "coffee_machine",
    "condition": {
        "name": "Number of Coffees Made",
        "operator": ">=",
        "value": 3
    }
}
```



#### Time conditions

A rule can depend on the current time to trigger. To create a such precondition, create an object with the properties `type` and `condition`.

The value of `type` is set to `Time`, `condition` is an object with `variable`, `operator`, and `value`.

The value of `variable` is set to the time variable (this can be either `minute` or `hour`), `operator` is the comparison operator, and `value` is the value to compare against.

```json
{
    "type": "Time",
    "condition": {
        "variable": "minute",
        "operator": ">=",
        "value": 10
    }
}
```

#### Context conditions

A rule can depend on the user's context to trigger. To create a such precondition, create an object with the properties `type` and `condition`.

The value of `type` is set to `Context`, `condition` is an object with `variable`, `operator`, and `value`.

The value of `variable` is set to the context variable (this can be any variable which has been passed when initiating a user session via the base64-encoded JSON object, such as group), `operator` is the comparison operator, and `value` is the value to compare against.

```json
{
    "type": "Context",
    "condition": {
        "variable": "group",
        "operator": "==",
        "value": "1"
    }
}
```

#### Current task

A rule can depend on the user's current task to trigger. To create a such precondition, create an object with the properties `type` and `condition`.

The value of `type` is set to `Context`, `condition` is an object with `variable`, `operator`, and `value`.

The value of `variable` is set to `task`, `operator` is the comparison operator (here, it should be `==`), and `value` is the task ID to compare against.

```json
{
    "type": "Context",
    "condition": {
        "variable": "task",
        "operator": "==",
        "value": "deep_fryer"
    }
}
```

### Actions

#### Device interactions

A rule can change a device's state. To create a such action, create an object with the properties `type`, `device`, and `interaction`.

The value of `type` is set to `Device_Interaction`, `device` is set to the device's name ID.

In the `interaction`, `name` is the property name, and `value` is the value to set.

```json
{
    "type": "Device_Interaction",
    "device": "coffee_machine",
    "interaction": {
        "name": "Power",
        "value": false
    }
}
```

#### Explanations

A rule can issue an explanation. To create a such action, create an object with the properties `type` and `explanation`.

The value of `type` is set to `Explanation`, `explanation` is the explanation ID which correspond to the ID in `explanation.json`.

```json
{
    "type": "Explanation",
    "explanation": "coffee_01"
}
```

## Example

```json
{
    "rules": [
        {
            "id": "coffee_machine_rule",
            "name": "Turn Off Coffee Machine",
            "precondition": [
                {
                    "type": "Device",
                    "device": "coffee_machine",
                    "condition": {
                        "name": "Number of Coffees Made",
                        "operator": ">=",
                        "value": 3
                    }
                },
                {
                    "type": "Time",
                    "condition": {
                        "variable": "minute",
                        "operator": ">=",
                        "value": 10
                    }
                }
            ],
            "delay": 2,
            "action": [
                {
                    "type": "Device_Interaction",
                    "device": "coffee_machine",
                    "interaction": {
                        "name": "Power",
                        "value": false
                    }
                }
            ]
        }
    ]
}
```
## Best Practices

- Design intentional contradictions if your goal is to create confusing situations
- Test rule interactions thoroughly
- Use meaningful IDs for rules to make debugging and maintenance easier
- Consider using delays for rules that should have realistic timing behavior

:::important Rule Design
Use rules if you want to create impossible tasks:
- Design contradictions between goals and rules
- Create cascading rule effects
- Ensure impossibility is clear but not immediately obvious
:::