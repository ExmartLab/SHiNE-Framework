---
sidebar_position: 6
---

import ExplanationEngine from "@site/static/schemas/explanationEngine.json";
import JSONSchemaViewer from "@theme/JSONSchemaViewer";
import generateResolverOptions from "@site/src/components/shared-lib/generateResolverOptions.tsx";
import CodeBlock from '@theme/CodeBlock';

# Explanation Engine

This documentation guides on how to integrate an explanation engine to the study.
Two approaches exist integrating explanation, by using the integrated one or a custom API endpoint. Both approaches are detailed below

## Core Configuration

In the core configuration, the design of the explanation system can be adjusted.
These are the time of when explanations are issued and the type of explanation system used.

### Property: Explanation Trigger

There are multiple ways exist to trigger an explanation which is described below

- `on_demand`: Explanations can be shown on demand, in particular, when an user requests an explanation via a button click on 'Explain Me'. In this case, the held back explanation in cache will be shown to the user.
- `automatic`: If one of the condititions of a rule apply, an explanation will be issued automatically to the end-user. Similarly, if the exernal explanation engine emits an explanation, it will be shown immediately to the user.

### Property: Explanation Engine

The type back-bone of the explanation engine can be adjusted here.

One can decide to use the integrated explanation engine which is suitable for simple explanation that do not depend on complex logic and dynamicity.

Alternatively, an external explanation engine can be used for cases that goes beyond the limits of the external explanation engine.
If an external explanation engine is used, one needs to specify the URL in `external_explanation_engine_api`.

Therefore, the property `explanation_engine` accepts two values:
- `integrated`: For the use of the integrated explanation engine
- `external`: For the use of the external explanation engine

### Property: Allow User Messages

Interactivity between the user and external explanation engine can be realized by allowing the user to pass messages to the external explanation engine.

This realizes use-cases when the external explanation engine should not _predict_ the explanation based solely on user logs, but should engage directly with the user to clarify context and gather real-time feedback.

To realize it, `allow_user_message` needs to be set to `true`.

```json
{
    "allow_user_message": true
}
```

### Property: Explanation Rating

Explanations can optionally be rated using likes, e.g., thumbs-up or thumbs-down. This way, user can rate explanations which can be leveraged to analyze its usefulness.

To enable the 'like'-rating, `explanation_rating` needs to be set to `like`.

```json
{
    "explanation_rating": "like"
}
```

### JSON Scheme

<JSONSchemaViewer schema={ ExplanationEngine } resolverOptions={generateResolverOptions({"basePath": "/schemas"})} />

<CodeBlock language="json-schema">{JSON.stringify(ExplanationEngine, null, 2)}</CodeBlock>

## Explanation Engines

In the following, both types of the explanation engines integrated or an external one will be detailed.

### Integrated Explanation Rule Engine

The integrated explanation rule engine simplifies setting up new rules along with associated explanations.

#### Setup

If one chooses the explanation engine, the core properties should be adjusted as follow:
- `explanation_engine` needs to be set to `integrated`.
- `explanation_trigger` needs to be either set to `on_demand` or `automatic`.

#### When is an explanation shown?

Depending on the configuration of `explanation_trigger`, an explanation will be shown on-demand or immediately via automatic.

When setting up automatic, the explanations will be shown immediately to the user whenever all conditions of an explanation object will apply.

In the on-demand setting, it's similarly realised by storing the latest explanation that gets changed whenever the conditions of an explanation object applies.
In the on demand setting however, an explanation will be held back in the cache whenver all conditions of an explanation object will apply.
That held back explanation in the cache will be shown to the user when the user requests an explanation via the button 'Explain Me!'. This action clears the explanation cache.

In other words, if a user requests an explanation, the latest explanation will be retrieved and then shown to the user. In other words, the explanation won't be disclosed until requested by the user.

#### Create new Explanation

To create new explanation for the internal explanation engine, a JSON object need to be defined in the JSON object `integrated_explanation_engine` with the key being the ID of the explanation and the value the explanation itself.

```json
{
    "integrated_explanation_engine": {
        "explanation_id": "explanation_text"
    }
}
```


### External Explanation Engine

The external explanation engine allows for greater customization and suitable for already existing explanation engines.

#### Setup

If one chooses the explanation engine, it should be decided between REST API or Websockets, therefore the core properties should be adjusted as follow:
- `explanation_engine` needs to be set to `external`.
- `external_engine_type` needs to be set either to `ws` or `rest`
- `explanation_trigger` needs to be either set to `on_demand` or `automatic`.

For REST:
- `external_explanation_engine_api`: URL of the explanation engine, e.g., `https://example.com/engine` (without slash at the end).

For Websockets:
- `external_explanation_engine`: URL of the Websocket server, e.g., `ws://example.com`

#### Explanation Engine via REST API

This documentation is intended if one uses the REST API communication

The explanation engine requires two endpoints of the API:
- `/logger`: The standard endpoint, called when the user interacted within the game and caused new logs to be sent to the endpoint.
- `/explanation`: If an user requests an explanation on-demand, this endpoint will be called

Both endpoints will be called with a general JSON payload consisting of the user ID:

```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a"
}
```

If the external explanation engine API is https://example.com/engine, then the endpoints are as follow specified
- https://example.com/engine/logger
- https://example.com/engine/explanation


##### Endpoint: `/logger`

The `/logger` endpoint will be called whenever the user interacted with a device or performed some actions within the game, leading to logging of its activities.
These logging activities are transmitted to the endpoint whenever a new log is available. In addition, meta-data of the devices and environments are also included.
In the REST interface, all logged data will be transmitted within `logs`.

The example JSON payload follows the example:

```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a",
    "current_task": "make_coffee",
    "ingame_time": "08:32",
    "environment": [
        { "name": "Weather", "value": "Sunny" },
        { "name": "Temperature", "value": 20 }
    ],
    "devices": [
        {
            "device": "deep_fryer",
            "interactions": [
                {
                    "name": "Power",
                    "value": true
                },
                {
                    "name": "Temperature",
                    "value": 150
                }
            ]
        },
        {
            "device": "coffee_machine",
            "interactions": [
                {
                    "name": "Power",
                    "value": true
                },
                {
                    "name": "Roasting",
                    "value": true
                }
            ]
        }
    ],
    "logs": [
        {
            "type": "DEVICE_INTERACTION",
            "device_id": "deep_fryer",
            "interaction": {
                "name": "Power",
                "value": true
            },
            "timestamp": 1739280520
        },
        {
            "type": "DEVICE_INTERACTION",
            "device_id": "coffee_machine",
            "interaction": {
                "name": "Power",
                "value": true
            },
            "timestamp": 1739280574
        }
    ]
}
```

The API response of the endpoint is dedicated in the following section.

##### Endpoint: `/explanation`

The `/explanation` endpoint will be called whenever a user requests an explanation on-demand via button click.

The API endpoint will be sent with the user ID and optionally with the user-passed message.

**Standard Explanation Request**

```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a"
}
```

**Explanation Request with user message**

```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a",
    "user_message": "User message ..."
}
```

To pass user-messages to the explanation engine, the setting `allow_user_message` must be set to `true`.

The API response of the endpoint is dedicated in the next section

##### API Response 

The API response should return the HTTP code 200 if successful.
Further, if an explanation should be shown for the API endpoint `/logger` or `/explanation`, the response should follow the output:

```json
{
    "success": true,
    "show_explanation": true,
    "explanation": "..."
}
```

On the contrary, if no explanations is shown, the response should follow the output:

```json
{
    "success": true,
    "show_explanation": false
}
```

#### Explanation Engine via WebSockets

#### Explanation Engine via WebSockets

This document outlines the WebSocket communication protocol implemented for the study platform. The WebSocket server facilitates real-time communication through dedicated channels and events.

##### Connection Details
- **Protocol**: WebSocket
- **Communication Pattern**: Event-based

##### Events

###### Outgoing: User Metadata Event
**Event Name**: `user_log`

**Description**

The `user_log` event provides comprehensive information about the user's current state, including their identification, current task, in-game time, environmental conditions, device states and logs. 

**Payload Structure**
```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a",
    "current_task": "make_coffee",
    "ingame_time": "08:32",
    "environment": [
        { "name": "Weather", "value": "Sunny" },
        { "name": "Temperature", "value": 20 }
    ],
    "devices": [
        {
            "device": "deep_fryer",
            "interactions": [
                {
                    "name": "Power",
                    "value": true
                },
                {
                    "name": "Temperature",
                    "value": 150
                }
            ]
        },
        {
            "device": "coffee_machine",
            "interactions": [
                {
                    "name": "Power",
                    "value": true
                },
                {
                    "name": "Roasting",
                    "value": true
                }
            ]
        }
    ],
    "logs": {
        "type": "DEVICE_INTERACTION",
        "device_id": "deep_fryer",
        "interaction": {
            "name": "Power",
            "value": true
        },
        "timestamp": 1739280520
    }
}
```


###### Outgoing: Explanation Request
**Event Name**: `explanation_request`

**Description**

The `explanation_request` event captures the request of an explanation. This event is emitted whenever a user requests an explanation using a button click.
Furthermore, it can contain optionally the user-passed message.

**Standard Explanation Request Payload**
```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a",
    "timestamp": 1739792380
}
```

**Explanation Request with User Message Payload**
```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a",
    "timestamp": 1739792380,
    "user_message": "Message"
}
```

**Field Descriptions**
- `user_id`: Identifier for the user
- `timestamp`: Timestamp of the event

###### Incoming: Explanation Receival

To receive the explanations back, the channel `explanation_receival` will be listened for new incoming explanations.

It should follow the JSON payload:
```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a",
    "explanation": "It's me, an explanation!"
}
```

:::info
In case, on demand explanations are enabled, explanations are held back until the user requests it.
In rare cases, one wish to enforce an automatic explanations that is shown to the user immediately.
Thus, the user can set `enforce_automatic_explanation` to `true`
:::

```json
{
    "user_id": "64bdb062-cb25-487f-8373-c56ac18fba5a",
    "explanation": "It's me, an explanation!",
    "enforce_automatic_explanation": true
}
```

**Field Descriptions**
- `user_id`: Identifier for the user
- `explanation`: Explanation
- `enforce_automatic_explanation`: Enforce to show automatic explanation via `true`

**Implementation Notes**
- All timestamps are provided in Unix timestamp format

**Error Handling**
Clients should implement appropriate error handling for:
- Connection interruptions
- Invalid payload formats
- Missing required fields

**Security Considerations**
- Validate all incoming payloads
- Implement appropriate authentication mechanisms
- Monitor for unusual patterns in event frequency

## Log Types

Below, all possible log types are outlined that can occur during the game.

### RULE_TRIGGER

The log `RULE_TRIGGER` is created whenever a rule has been triggered, i.e., the actions of the rule has been fired.

```json
{
    "type": "RULE_TRIGGER",
    "metadata": {
        "rule_id": "deep_fryer_rule",
        "rule_action": [
            {
                "device": "deep_fryer",
                "property": {
                    "name": "Power",
                    "value": false
                }
            }
        ]
    },
    "timestamp": 1748860205
}
```

The metadata contains the information which rule has been triggered using the ID and the resulting action.

### ROOM_SWITCH

The log `ROOM_SWITCH` is created whenever the user switched to another room using a door.

```json
{
    "type": "ROOM_SWITCH",
    "metadata": {
        "destination_room": "alice_room",
        "destination_wall": "wall1"
    },
    "timestamp": 1748860201
}
```

The metadata contains the information to which room and wall the user switched using the door.

### WALL_SWITCH

The log `WALL_SWITCH` is created whenever the user switched to another wall within a room.

For example, when the user switches using the navigation buttons from `Wall 2` to `Wall 3`.

```json
{
    "type": "WALL_SWITCH",
    "metadata": {
        "room": "Shared Room",
        "wall": "0"
    },
    "timestamp": 1748860200
}
```

The metadata contains the information which wall has been switched to.

### ENTER_DEVICE_CLOSEUP

The log `ENTER_DEVICE_CLOSEUP` is created whenever the user clicks on the device, thereby switching to the close-up of the device.

```json
{
    "type": "ENTER_DEVICE_CLOSEUP",
    "metadata": {
        "device": "book"
    },
    "timestamp": 1748860202
}
```

The metadata contains the information from which device the close-up has been entered.

### EXIT_DEVICE_CLOSEUP

The log `EXIT_DEVICE_CLOSEUP` is created whenever the user returns from the close-up view of the device to the wall view.

```json
{
    "type": "EXIT_DEVICE_CLOSEUP",
    "metadata": {
        "device": "book"
    },
    "timestamp": 1748860203
}
```

The metadata contains the information from which device the close-up has been exited.

### DEVICE_INTERACTION

The log `DEVICE_INTERACTION` is created whenever the user interacted with the device through the numerical or boolean interaction, i.e., changing the device's properties.

```json
{
    "type": "DEVICE_INTERACTION",
    "metadata": {
        "device_id": "deep_fryer",
        "interaction": {
            "name": "Power",
            "value": true
        }
    },
    "timestamp": 1748860205
}
```

The metadata contains the information with which device has been interacted and the interaction that has been changed to which value.

### TASK_BEGIN

The log `TASK_BEGIN` is created when a new task has been started.

```json
{
    "type": "TASK_BEGIN",
    "metadata": {
        "task_id": "deep_fryer"
    },
    "timestamp": 1748860190
}
```

The metadata contains the information which task has been started.

### ABORT_TASK

The log `ABORT_TASK` is created whenever the user aborted a task using the abort-task modal.

```json
{
    "type": "ABORT_TASK",
    "metadata": {
        "task_id": "turn_on_mixer",
        "abort_reason": "I want to skip this task."
    },
    "timestamp": 1748862023
}
```

The metadata contains the information which task has been aborted and for which reason.

### TASK_TIMEOUT

The log `TASK_TIMEOUT` is created whenever a task has been timed out. This is created when the user did not successfully completed the task goals within time, thus leading to expiring the task and starting the next task.

```json
{
    "type": "TASK_TIMEOUT",
    "metadata": {
        "task_id": "book"
    },
    "timestamp": 1748862033
}
```

The metadata contains the information which task has been timed out.

### TASK_COMPLETED

The log `TASK_COMPLETED` is created whenever the user finished the task, i.e., completed all task goals.

```json
{
    "type": "TASK_COMPLETED",
    "metadata": {
        "task_id": "deep_fryer"
    },
    "timestamp": 1748862020
}
```

The metadata contains the information which task has been completed.