---
sidebar_position: 6
---

import JSONSchemaViewer from "@theme/JSONSchemaViewer";
import NumericalAction from "@site/static/schemas/device/numericalActionScheme.json";
import BooleanAction from "@site/static/schemas/device/booleanActionScheme.json";
import InlineSchemaDisplay from '@site/src/components/InlineSchemaDisplay';
import generateResolverOptions from "@site/src/components/shared-lib/generateResolverOptions.tsx";

# Interacting with Devices

Interacting with devices is a pivotal part of any smart environment simulation. In our system, each device not only has a visual representation in the scene (Fig. 1), 
but also a virtual control panel (Fig. 2) through which participants can interact with the device's internal logic, such as powering it on/off or adjusting a temperature setting. 
These control panels are dynamically rendered based on an abstract interaction model.
Creating a unique control panel for every possible smart device is impractical. To support generalizability across many device types( From sensors to smart home appliance), 
we adopt a structured interaction model inspired by the [W3C Thing Description (TD)](https://www.w3.org/TR/wot-thing-description10/#introduction), extended via [TDeX](https://ieeexplore.ieee.org/abstract/document/8726632). While TD includes metadata for networking and affordances, 
TDeX focuses on interaction types and their corresponding GUI elements.

Accoridng to TDeX, smart devices may vary greatly in appearance, complexity, and capabilities, yet the types of interactions users perform fall into a small number of reusable categories. For example:

- Turning a heater on or off is conceptually similar to locking or unlocking a door. Both involve a two-state toggle that alternates between binary values (e.g., on/off, locked/unlocked). 
These interactions are typically visualized using a switch or toggle button in the control panel.

- Setting the temperature of a deep fryer or adjusting the brightness of a smart light involves choosing a value from a continuous or discrete numerical range. 
Such interactions are best represented via a slider, allowing users to quickly navigate the spectrum of available values.

- Some actions are independent of internal device state and can be performed repeatedly without regard to current conditions. 
Examples include taking a snapshot with a security camera or dispensing food from a pet feeder. These actions are most intuitively presented via a button, 
which simply triggers the action on press.


TDeX captures this insight by categorizing all interactions into a small, expressive set of **interaction types**, each linked to a specific GUI element for rendering in the control panel.



| Type              | Description                              | Example                             | GUI Element                     |
|-------------------|------------------------------------------|-------------------------------------|----------------------------------|
| Dynamic Property  | Continuously updated internal state      | Temperature of fryer                | Text/Label bound to state        |
| Static Property   | Fixed attribute of a device              | Model number                        | Text (non-interactive)           |
| Stateless Action  | No internal state dependency             | Take snapshot                       | Button                           |
| Boolean Action    | Two-valued toggleable state              | Power on/off                        | Toggle switch                    |
| Numerical Action  | Range-based parameter setting            | Temperature, brightness             | Slider or input box              |
| Generic Action    | Enum-based selection from fixed values   | Washing machine modes               | Dropdown                         |
| Composed Action   | Composite of multiple atomic actions     | Order coffee (milk + sugar + type) | Grouped UI with trigger          |
| Grouped Devices   | Aggregation across device sets           | Multiple thermostats                | Aggregated UI element            |

## Boolean Action 
A **Boolean Action** models an interaction with exactly **two possible states**, such as `on/off`, `enabled/disabled`, or `open/close`. 
This type of interaction is ideal for simple toggles and switch-like controls, and is one of the most common primitives in smart home interfaces.  

**Common Use Cases**:

- Power toggle (e.g., turning a coffee machine on/off)  
- Binary operating modes (e.g., High vs. Low)  
- Physical state detection (e.g., book open/closed)

### JSON Schema

<JSONSchemaViewer schema={ BooleanAction } />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={BooleanAction} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas"})} 
    title="Boolean Action Schema"
    />
</details>

A **Boolean Action** is defined in the interaction model using the following key fields:

- `InteractionType`: This must be set to `"Boolean_Action"` to identify the interaction as a two-state toggle.

- `name`: The human-readable label displayed in the GUI (e.g., `"Power"` or `"Mode"`).

- `inputData`: Specifies how the interaction is configured:
    - `"valueType"`: Always `["PrimitiveType", "Boolean"]`
    - `"unitOfMeasure"`: Set to `null` (no unit applies)
    - `"type"`: A mapping between Boolean values (`true` / `false`) and display strings (e.g., `"On"`, `"Off"`)
    
- `currentState`:  Defines the initial state of the interaction and controls its visibility:
    - `"value"`: Initial state (`true` or `false`)
    - `"visible"`: Determines if/when the interaction is accessible to the user.

- `visible` : It supports flexible control over when the interaction should be shown and whether it is interactive. This is useful for dependent settings, like a `"Mute"` toggle that only appears after the TV is powered on.
    - `null`: Always visible and interactive  
    - `true`: Always visible and editable  
    - `false`: Always visible but read-only  
    - *Array of conditions*: Visible only when specified device state conditions are satisfied  

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Power",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "On",
            "False": "Off"
        }
    },
    "currentState": {
        "visible": null,
        "value": false
    }
}
```
This defines a power control with:
- A toggle rendered with "On" and "Off" labels
- Initial state set to "Off"
- Always visible and interactive

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Open",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "Yes",
            "False": "No"
        }
    },
    "currentState": {
        "visible": null,
        "value": false
    }
}
```
This defines a binary state for whether a book is opened or closed.

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Mode",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "High",
            "False": "Low"
        }
    },
    "currentState": {
        "visible": [
            { "name": "Power", "value": true }
        ],
        "value": false
    }
}
```
In this example, the `Mode` toggle is only **visible** when the device's `Power` is On. This supports context-sensitive GUI behavior and reflects realistic constraints in physical appliances.

## Boolean Action old

A boolean action is a dynamic property for boolean values. It represents binary states such as ON/OFF, enabled/disabled, or any two-state configuration.

Boolean actions are ideal for:
- Power switches (On/Off)
- Mode toggles (High/Low, Fast/Slow)
- Binary settings (Enabled/Disabled)

### Example of a Boolean Action

Let's examine a deep fryer that can be turned on or off, which we name `Power`. This is realized through a boolean action.

#### InteractionType Property

The `InteractionType` must be set to `"Boolean_Action"` to identify this as a boolean interaction.

#### Name Property

The `name` property defines the display name for this interaction, such as `"Power"` for a power switch.

#### Input Data Configuration

The `inputData` object contains the configuration for the boolean action:

- **`valueType`**: Always `["PrimitiveType", "Boolean"]` for boolean actions
- **`unitOfMeasure`**: Set to `null` for boolean actions (no units apply)
- **`type`**: Maps boolean values to display strings

#### Value Mapping

We map the two states of the boolean action to device values within `type`:
- **True state** (value = true): Maps to display string (e.g., "On")
- **False state** (value = false): Maps to display string (e.g., "Off")

#### Current State

The `currentState` defines the initial state and visibility conditions:
- **`value`**: Set to `true` (On) or `false` (Off) for the initial state
- **`visible`**: Controls when this interaction is available to participants

#### Visibility Control

The `visible` property can be set to:
- **`null`**: Always visible and interactive with no constraints
- **`true`**: Always visible and interactive
- **`false`**: Always visible but read-only (value shown but cannot be changed)
- **Array of conditions**: Interactive only when specified conditions are met

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Power",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "On",
            "False": "Off"
        }
    },
    "currentState": {
        "visible": null,
        "value": false
    }
}
```

### Additional Boolean Action Examples

#### Mode Toggle with Conditional Visibility

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Mode",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "High",
            "False": "Low"
        }
    },
    "currentState": {
        "visible": [
            { "name": "Power", "value": true }
        ],
        "value": false
    }
}
```

This mode toggle is only visible when the device's Power is turned on.

#### Book Open/Close State

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Open",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "Yes",
            "False": "No"
        }
    },
    "currentState": {
        "visible": null,
        "value": false
    }
}
```

### JSON Schema

<JSONSchemaViewer schema={ BooleanAction } />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={BooleanAction} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas"})} 
    title="Boolean Action Schema"
    />
</details>

## Numerical Action

A numerical action is a dynamic property for numerical values. It accepts values within a pre-defined range at predefined intervals.

Numerical actions are useful for:
- Temperature controls (ovens, heaters, air conditioners)
- Volume settings (speakers, TVs)
- Speed controls (fans, mixers)
- Brightness levels (lights, displays)

### Example of a Numerical Action

Let's examine a deep fryer with the option to set temperature in discrete steps. The `name` is set to `Temperature`, which will be displayed in the smart home panel for viewing the current value and adjusting it.

#### InteractionType Property

The `InteractionType` must be set to `"Numerical_Action"` to identify this as a numerical interaction.

#### Input Data Configuration

The `inputData` object contains the configuration for the numerical action:

- **`valueType`**: Always `["PrimitiveType", "Integer"]` for numerical actions
- **`unitOfMeasure`**: Unit displayed with the value (e.g., "°C", "dB", "%")
- **`type`**: Defines the range and interval constraints

#### Value Range Configuration

The temperature can be adjusted from 0 to 250 degrees Celsius:
- **`Range`**: Set to `[0, 250]` defining minimum and maximum values
- **`Interval`**: Set to `[25]` defining the step size between valid values

This configuration allows the following 11 values: `0`, `25`, `50`, `75`, `100`, `125`, `150`, `175`, `200`, `225`, `250`.

#### Current State

The `currentState` defines the initial value and visibility conditions:
- **`value`**: Set to the initial numerical value (e.g., `0`)
- **`visible`**: Controls when this interaction is available

#### Conditional Visibility

In this example, the temperature control is only visible when the deep fryer's power is turned on:

```json
{
    "InteractionType": "Numerical_Action",
    "name": "Temperature",
    "inputData": {
        "valueType": ["PrimitiveType", "Integer"],
        "unitOfMeasure": "°C",
        "type": {
            "Range": [0, 250],
            "Interval": [25]
        }
    },
    "currentState": {
        "visible": [
            { "name": "Power", "value": true }
        ],
        "value": 0
    }
}
```

### Additional Numerical Action Examples

#### Volume Control

```json
{
    "InteractionType": "Numerical_Action",
    "name": "Volume",
    "inputData": {
        "valueType": ["PrimitiveType", "Integer"],
        "unitOfMeasure": "dB",
        "type": {
            "Range": [0, 100],
            "Interval": [10]
        }
    },
    "currentState": {
        "visible": [
            { "name": "Power", "value": true }
        ],
        "value": 50
    }
}
```

#### Read-Only Temperature Display

```json
{
    "InteractionType": "Numerical_Action",
    "name": "Current Temperature",
    "inputData": {
        "valueType": ["PrimitiveType", "Integer"],
        "unitOfMeasure": "°C",
        "type": {
            "Range": [0, 100],
            "Interval": [1]
        }
    },
    "currentState": {
        "visible": false,
        "value": 25
    }
}
```

This displays the current temperature but participants cannot change it via slider controls.

### JSON Schema

<JSONSchemaViewer schema={ NumericalAction } />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={NumericalAction} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas"})} 
    title="Numerical Action Schema"
    />
</details>

## Visibility Conditions

Both interaction types support sophisticated visibility control through the `visible` property in `currentState`.

### Visibility Options

1. **Always Interactive**: `"visible": null` or `"visible": true`
2. **Read-Only Display**: `"visible": false` - Value is shown but cannot be changed via UI controls
3. **Conditional Interactivity**: Array of condition objects - Interactive only when conditions are met

### Conditional Visibility Examples

#### Single Condition

```json
"visible": [
    { "name": "Power", "value": true }
]
```

#### Multiple Conditions (AND Logic)

```json
"visible": [
    { "name": "Power", "value": true },
    { "name": "Mode", "value": "Advanced" }
]
```

All conditions must be satisfied for the interaction to be visible.

### Visibility Use Cases

- **Read-Only Status**: Show current values that cannot be directly controlled (e.g., sensor readings)
- **Safety Controls**: Disable dangerous settings until safety conditions are met
- **Progressive Disclosure**: Enable advanced options only when basic setup is complete
- **Context-Sensitive Controls**: Allow interaction only when relevant to current device state
- **Study Design**: Control which interactions participants can modify during different phases

## Integration with Visual States

Interaction values directly influence device visual states. When participants change interaction values, the device's appearance updates according to the visual state conditions.

### Example Integration

```json
// Boolean interaction
{
    "InteractionType": "Boolean_Action",
    "name": "Power",
    "currentState": {
        "value": false
    }
}

// Corresponding visual states
{
    "visualState": [
        {
            "default": true,
            "image": "device_off.png"
        },
        {
            "conditions": [
                { "name": "Power", "value": true }
            ],
            "image": "device_on.png"
        }
    ]
}
```

When the Power interaction changes to `true`, the device automatically switches to the "on" visual state.

## Complete Device Example

Here's a complete device showing both interaction types working together:

```json
{
    "name": "Smart Oven",
    "id": "smart_oven",
    "image": "assets/images/kitchen/oven.png",
    "position": {
        "x": 400,
        "y": 300,
        "scale": 1.0,
        "origin": 0.5
    },
    "interactions": [
        {
            "InteractionType": "Boolean_Action",
            "name": "Power",
            "inputData": {
                "valueType": ["PrimitiveType", "Boolean"],
                "unitOfMeasure": null,
                "type": {
                    "True": "On",
                    "False": "Off"
                }
            },
            "currentState": {
                "visible": null,
                "value": false
            }
        },
        {
            "InteractionType": "Numerical_Action",
            "name": "Temperature",
            "inputData": {
                "valueType": ["PrimitiveType", "Integer"],
                "unitOfMeasure": "°C",
                "type": {
                    "Range": [100, 250],
                    "Interval": [25]
                }
            },
            "currentState": {
                "visible": [
                    { "name": "Power", "value": true }
                ],
                "value": 150
            }
        }
    ],
    "visualState": [
        {
            "default": true,
            "image": "assets/images/kitchen/oven_off.png"
        },
        {
            "conditions": [
                { "name": "Power", "value": true }
            ],
            "image": "assets/images/kitchen/oven_on.png"
        }
    ]
}
```