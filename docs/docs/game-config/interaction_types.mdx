---
sidebar_position: 6
---

import JSONSchemaViewer from "@theme/JSONSchemaViewer";
import NumericalAction from "@site/static/schemas/device/numericalActionScheme.json";
import BooleanAction from "@site/static/schemas/device/booleanActionScheme.json";
import InlineSchemaDisplay from '@site/src/components/InlineSchemaDisplay';
import generateResolverOptions from "@site/src/components/shared-lib/generateResolverOptions.tsx";

# Interacting with Devices

Interacting with devices is a pivotal part of any smart environment simulation. In our system, each device not only has a visual representation in the scene (Fig. 1), 
but also a virtual control panel (Fig. 2) through which participants can interact with the device's internal logic, such as powering it on/off or adjusting a temperature setting. 
These control panels are dynamically rendered based on an abstract interaction model.
Creating a unique control panel for every possible smart device is impractical. To support generalizability across many device types( From sensors to smart home appliance), 
we adopt a structured interaction model inspired by the [W3C Thing Description (TD)](https://www.w3.org/TR/wot-thing-description10/#introduction), extended via [TDeX](https://ieeexplore.ieee.org/abstract/document/8726632). While TD includes metadata for networking and affordances, 
TDeX focuses on interaction types and their corresponding GUI elements.

Accoridng to TDeX, smart devices may vary greatly in appearance, complexity, and capabilities, yet the types of interactions users perform fall into a small number of reusable categories. For example:

- Turning a heater on or off is conceptually similar to locking or unlocking a door. Both involve a two-state toggle that alternates between binary values (e.g., on/off, locked/unlocked). 
These interactions are typically visualized using a switch or toggle button in the control panel.

- Setting the temperature of a deep fryer or adjusting the brightness of a smart light involves choosing a value from a continuous or discrete numerical range. 
Such interactions are best represented via a slider, allowing users to quickly navigate the spectrum of available values.

- Some actions are independent of internal device state and can be performed repeatedly without regard to current conditions. 
Examples include taking a snapshot with a security camera or dispensing food from a pet feeder. These actions are most intuitively presented via a button, 
which simply triggers the action on press.


TDeX captures this insight by categorizing all interactions into a small, expressive set of **interaction types**, each linked to a specific GUI element for rendering in the control panel.



| Type              | Description                              | Example                             | GUI Element                     |
|-------------------|------------------------------------------|-------------------------------------|----------------------------------|
| Dynamic Property  | Continuously updated internal state      | Temperature of fryer                | Text/Label bound to state        |
| Static Property   | Fixed attribute of a device              | Model number                        | Text (non-interactive)           |
| Stateless Action  | No internal state dependency             | Take snapshot                       | Button                           |
| Boolean Action    | Two-valued toggleable state              | Power on/off                        | Toggle switch                    |
| Numerical Action  | Range-based parameter setting            | Temperature, brightness             | Slider or input box              |
| Generic Action    | Enum-based selection from fixed values   | Washing machine modes               | Dropdown                         |
| Composed Action   | Composite of multiple atomic actions     | Order coffee (milk + sugar + type) | Grouped UI with trigger          |

## Interaction Schema
An Interaction is described by a set of key properties:

- `InteractionType`: Specifies the type of the action (e.g., Stateless_Action, Boolean_Action, etc.), which directly determines its behavior and corresponding visualization of the control panel.

- `name`: A string that labels the action in the GUI (e.g., "Take Snapshot","Power").

- `inputData`: Defines the required input structure â€” such as value type, range, unit, or discrete values.

- `currentState`: Describes the current internal value of the action (if applicable), as well as its visibility in the GUI.

- `visible` : It supports flexible control over when the interaction should be shown and whether it is interactive. 
This is useful for dependent settings, like a "Mute" toggle that only appears after the TV is powered on (see [Visibility Conidtion](#Visibility-Conditions))

> ðŸ“Œ **TODO:**  what is the difference between null and true?


- `output` (optional): in most cases, the output of an action in a smart device results in a physical effect on the device or its environment, such as turning a light on or off, 
making a coffee, or opening a door. However, in some instances, actions may also produce structured output, such as a duration or a calculated value.
For example, when the "Start" action is triggered on a washing machine, in addition to changing the systemâ€™s state, 
it may also calculate and visually display the estimated time needed to complete the washing cycle, based on the selected program and the weight of the clothes. These outputs are encoded as part of the actionâ€™s schema.

> ðŸ“Œ **TODO:**  Add visualization of the control panel for various types of action.

## Stateless Action
A **Stateless Action** models an interaction that does **not store or depend on internal state**. It can be triggered any number of times and is designed 
for event-like, one-shot operations. This is the simplest type of interaction in TDeX and is typically used for actions that are repeatable, non-parameterized, 
and do not alter persistent device status.

**Common Use Cases**:
- Actions that are purely event-driven, without requiring or updating internal state  
- Actions that can be executed repeatedly without restriction  
- Actions that result in external effects, such as mechanical or sensory responses (e.g., flashes, sounds, movement), but do not toggle or store values  

### JSON Schema

> ðŸ“Œ **TODO:**  To add JSON Schema for Stateless Action


## Boolean Action 
A **Boolean Action** models an interaction with exactly **two possible states**, such as `on/off`, `enabled/disabled`, or `open/close`. 
This type of interaction is ideal for simple toggles and switch-like controls, and is one of the most common primitives in smart home interfaces.  

**Common Use Cases**:

- Power toggle (e.g., turning a coffee machine on/off)  
- Binary operating modes (e.g., High vs. Low)  
- Physical state detection (e.g., book open/closed)

### JSON Schema

<JSONSchemaViewer schema={ BooleanAction } />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={BooleanAction} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas"})} 
    title="Boolean Action Schema"
    />
</details>

The specification of Interaction's fields (introduced above) for a  **Boolean Action** are as follows:

- `InteractionType`: This must be set to *"Boolean_Action"* to identify the interaction as a two-state toggle.

- `inputData`: 
    - `"valueType"`: This must be set to *["PrimitiveType", "Boolean"]*
    - `"unitOfMeasure"`: Set to *"null"* (no unit applies for Boolean Action)
    - `"type"`: A mapping between Boolean values (`true` / `false`) and display strings (e.g., *"On"*, *"Off"*)

- `currentState`
    - `"value"`: The current or initial state (`true` or `false`)
    - `"visible"`: Visibility flag or condition  (see [Visibility Conidtion](#Visibility-Conditions))
    

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Power",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "On",
            "False": "Off"
        }
    },
    "currentState": {
        "visible": true,
        "value": true
    }
}
```
This defines a Power control (for example, as part of an electric device) with the following characteristics:
- A toggle rendered with "On" and "Off" labels
- Initial state set to "ON" as the `value` in `CurrentState` is set to true.
- Always visible and interactive

```json
{
    "InteractionType": "Boolean_Action",
    "name": "Mode",
    "inputData": {
        "valueType": ["PrimitiveType", "Boolean"],
        "unitOfMeasure": null,
        "type": {
            "True": "High",
            "False": "Low"
        }
    },
    "currentState": {
        "visible": [
            { "name": "Power", "value": true }
        ],
        "value": false
    }
}
```
In this example, the Mode toggle has two states of "High" and "Low", which could, for example, represent an interaction type for a fan. 
The `value` in `currentState` is set to "true", indicating that on initial rendering, the toggle is set to "Low".

Furthermore, the toggle is visible only when the deviceâ€™s Power is "On" supporting context-sensitive visualization and reflecting realistic constraints found in physical appliances (see [Visibility Conidtion](#Visibility-Conditions)).

## Numerical Action 

A **Numerical Action** models an interaction that involves selecting a value from a predefined numerical range, such as setting temperature, adjusting brightness, or choosing volume levels. It supports discrete intervals and is rendered using a slider or numeric input field in the user interface.

**Common Use Cases:**

- Used for continuous control interactions involving quantities such as temperature, brightness, speed, or volume  
- Designed for bounded input ranges, where users can only select from a specified minimum and maximum  
- Can be configured to be interactive or read-only, depending on the current system state  
- Typically modeled using sliders or step-wise selectors, defined by a range and interval  

### JSON Schema

<JSONSchemaViewer schema={ NumericalAction } />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={NumericalAction} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas"})} 
    title="Numerical Action Schema"
    />
</details>

The specification of Interaction's fields  for a  ** Numerical Action** are as follows:

- `InteractionType`:  Must be set to *"Numerical_Action"* to declare the action as numerical.


- `inputData`:  
  - `"valueType"`: Always *["PrimitiveType", "Integer"]* for numerical actions  
  - `"unitOfMeasure"`: String label for unit (e.g., *"Â°C"*, *"dB"*, *"%"*)  
  - `"type"`:  
    - `"Range"`: *[min, max]* values defining the valid range  
    - `"Interval"`: Step size for permitted inputs  

- `currentState`:  
  - `"value"`: The current or initial numerical value shown in the interface  
  - `"visible"`: Visibility flag or condition  (see [Visibility Conidtion](#Visibility-Conditions))


> ðŸ“Œ **MERSEDEH:**  to continue from here





## Numerical Action OLD

A numerical action is a dynamic property for numerical values. It accepts values within a pre-defined range at predefined intervals.

Numerical actions are useful for:
- Temperature controls (ovens, heaters, air conditioners)
- Volume settings (speakers, TVs)
- Speed controls (fans, mixers)
- Brightness levels (lights, displays)

### Example of a Numerical Action

Let's examine a deep fryer with the option to set temperature in discrete steps. The `name` is set to `Temperature`, which will be displayed in the smart home panel for viewing the current value and adjusting it.

#### InteractionType Property

The `InteractionType` must be set to `"Numerical_Action"` to identify this as a numerical interaction.

#### Input Data Configuration

The `inputData` object contains the configuration for the numerical action:

- **`valueType`**: Always `["PrimitiveType", "Integer"]` for numerical actions
- **`unitOfMeasure`**: Unit displayed with the value (e.g., "Â°C", "dB", "%")
- **`type`**: Defines the range and interval constraints

#### Value Range Configuration

The temperature can be adjusted from 0 to 250 degrees Celsius:
- **`Range`**: Set to `[0, 250]` defining minimum and maximum values
- **`Interval`**: Set to `[25]` defining the step size between valid values

This configuration allows the following 11 values: `0`, `25`, `50`, `75`, `100`, `125`, `150`, `175`, `200`, `225`, `250`.

#### Current State

The `currentState` defines the initial value and visibility conditions:
- **`value`**: Set to the initial numerical value (e.g., `0`)
- **`visible`**: Controls when this interaction is available

#### Conditional Visibility

In this example, the temperature control is only visible when the deep fryer's power is turned on:

```json
{
    "InteractionType": "Numerical_Action",
    "name": "Temperature",
    "inputData": {
        "valueType": ["PrimitiveType", "Integer"],
        "unitOfMeasure": "Â°C",
        "type": {
            "Range": [0, 250],
            "Interval": [25]
        }
    },
    "currentState": {
        "visible": [
            { "name": "Power", "value": true }
        ],
        "value": 0
    }
}
```

### Additional Numerical Action Examples

#### Volume Control

```json
{
    "InteractionType": "Numerical_Action",
    "name": "Volume",
    "inputData": {
        "valueType": ["PrimitiveType", "Integer"],
        "unitOfMeasure": "dB",
        "type": {
            "Range": [0, 100],
            "Interval": [10]
        }
    },
    "currentState": {
        "visible": [
            { "name": "Power", "value": true }
        ],
        "value": 50
    }
}
```

#### Read-Only Temperature Display

```json
{
    "InteractionType": "Numerical_Action",
    "name": "Current Temperature",
    "inputData": {
        "valueType": ["PrimitiveType", "Integer"],
        "unitOfMeasure": "Â°C",
        "type": {
            "Range": [0, 100],
            "Interval": [1]
        }
    },
    "currentState": {
        "visible": false,
        "value": 25
    }
}
```

This displays the current temperature but participants cannot change it via slider controls.

### JSON Schema

<JSONSchemaViewer schema={ NumericalAction } />

<details>
    <summary>JSON Schema Code</summary>

    <InlineSchemaDisplay 
    schema={NumericalAction} 
    resolverOptions={generateResolverOptions({"basePath": "/schemas"})} 
    title="Numerical Action Schema"
    />
</details>

## Visibility Conditions

Both interaction types support sophisticated visibility control through the `visible` property in `currentState`.

### Visibility Options

1. **Always Interactive**: `"visible": null` or `"visible": true`
2. **Read-Only Display**: `"visible": false` - Value is shown but cannot be changed via UI controls
3. **Conditional Interactivity**: Array of condition objects - Interactive only when conditions are met

### Conditional Visibility Examples

#### Single Condition

```json
"visible": [
    { "name": "Power", "value": true }
]
```

#### Multiple Conditions (AND Logic)

```json
"visible": [
    { "name": "Power", "value": true },
    { "name": "Mode", "value": "Advanced" }
]
```

All conditions must be satisfied for the interaction to be visible.

### Visibility Use Cases

- **Read-Only Status**: Show current values that cannot be directly controlled (e.g., sensor readings)
- **Safety Controls**: Disable dangerous settings until safety conditions are met
- **Progressive Disclosure**: Enable advanced options only when basic setup is complete
- **Context-Sensitive Controls**: Allow interaction only when relevant to current device state
- **Study Design**: Control which interactions participants can modify during different phases

## Integration with Visual States

Interaction values directly influence device visual states. When participants change interaction values, the device's appearance updates according to the visual state conditions.

### Example Integration

```json
// Boolean interaction
{
    "InteractionType": "Boolean_Action",
    "name": "Power",
    "currentState": {
        "value": false
    }
}

// Corresponding visual states
{
    "visualState": [
        {
            "default": true,
            "image": "device_off.png"
        },
        {
            "conditions": [
                { "name": "Power", "value": true }
            ],
            "image": "device_on.png"
        }
    ]
}
```

When the Power interaction changes to `true`, the device automatically switches to the "on" visual state.

## Complete Device Example

Here's a complete device showing both interaction types working together:

```json
{
    "name": "Smart Oven",
    "id": "smart_oven",
    "image": "assets/images/kitchen/oven.png",
    "position": {
        "x": 400,
        "y": 300,
        "scale": 1.0,
        "origin": 0.5
    },
    "interactions": [
        {
            "InteractionType": "Boolean_Action",
            "name": "Power",
            "inputData": {
                "valueType": ["PrimitiveType", "Boolean"],
                "unitOfMeasure": null,
                "type": {
                    "True": "On",
                    "False": "Off"
                }
            },
            "currentState": {
                "visible": null,
                "value": false
            }
        },
        {
            "InteractionType": "Numerical_Action",
            "name": "Temperature",
            "inputData": {
                "valueType": ["PrimitiveType", "Integer"],
                "unitOfMeasure": "Â°C",
                "type": {
                    "Range": [100, 250],
                    "Interval": [25]
                }
            },
            "currentState": {
                "visible": [
                    { "name": "Power", "value": true }
                ],
                "value": 150
            }
        }
    ],
    "visualState": [
        {
            "default": true,
            "image": "assets/images/kitchen/oven_off.png"
        },
        {
            "conditions": [
                { "name": "Power", "value": true }
            ],
            "image": "assets/images/kitchen/oven_on.png"
        }
    ]
}
```